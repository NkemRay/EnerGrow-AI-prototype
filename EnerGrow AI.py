{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6db8067d-8598-4099-a78b-3485d4d3b3d8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# app_full.py\n",
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import joblib\n",
    "import os\n",
    "import json\n",
    "import requests\n",
    "from fpdf import FPDF\n",
    "import io\n",
    "import datetime\n",
    "\n",
    "# -------------------------\n",
    "# CONFIG\n",
    "# -------------------------\n",
    "MODEL_FILE = \"energrow_model.pkl\"\n",
    "ENCODERS_FILE = \"label_encoders.pkl\"\n",
    "SCALER_FILE = \"scaler.pkl\"\n",
    "DATA_FILE = \"EnerGrow_Nigeria_MVP_Dataset.csv\"\n",
    "LOG_FILE = \"predictions_log.csv\"\n",
    "\n",
    "# Quick conversion factors (example)\n",
    "CO2_REDUCTION_PER_SAVINGS_USD = 0.0008  # synthetic factor; adjust with real values later\n",
    "\n",
    "# Example supplier list (replace with your real supplier DB)\n",
    "SUPPLIERS = [\n",
    "    {\"name\": \"SolarWorks Nigeria\", \"tech\": \"Solar Dryer\", \"phone\": \"+2348010000001\", \"region\": \"Kpaduma\", \"price_naira\": 120000},\n",
    "    {\"name\": \"GreenStove Ltd\", \"tech\": \"Efficient Cookstove\", \"phone\": \"+2348010000002\", \"region\": \"Anambra\", \"price_naira\": 20000},\n",
    "    {\"name\": \"BioGas Co-op\", \"tech\": \"Biogas\", \"phone\": \"+2348010000003\", \"region\": \"Kaduna\", \"price_naira\": 450000},\n",
    "    {\"name\": \"Local Fitter\", \"tech\": \"Efficient Cookstove\", \"phone\": \"+2348010000004\", \"region\": \"Kpaduma\", \"price_naira\": 15000},\n",
    "]\n",
    "\n",
    "# -------------------------\n",
    "# UTILS: load model + preprocessors\n",
    "# -------------------------\n",
    "@st.cache_resource\n",
    "def load_artifacts():\n",
    "    model = joblib.load(MODEL_FILE)\n",
    "    encoders = joblib.load(ENCODERS_FILE)\n",
    "    scaler = joblib.load(SCALER_FILE)\n",
    "    return model, encoders, scaler\n",
    "\n",
    "def load_dataset_if_exists():\n",
    "    if os.path.exists(DATA_FILE):\n",
    "        return pd.read_csv(DATA_FILE)\n",
    "    else:\n",
    "        return None\n",
    "\n",
    "try:\n",
    "    model, label_encoders, scaler = load_artifacts()\n",
    "except Exception as e:\n",
    "    st.error(\"Failed to load model artifacts. Ensure energrow_model.pkl, label_encoders.pkl, scaler.pkl are present.\")\n",
    "    st.stop()\n",
    "\n",
    "df_ref = load_dataset_if_exists()\n",
    "\n",
    "# -------------------------\n",
    "# UI: Theme and header\n",
    "# -------------------------\n",
    "st.set_page_config(page_title=\"EnerGrow AI â€” Full Prototype\", layout=\"wide\", page_icon=\"ðŸŒ¿\")\n",
    "\n",
    "st.markdown(\n",
    "    \"\"\"\n",
    "    <style>\n",
    "    .reportview-container { background: linear-gradient(180deg, #f7fff7 0%, #ffffff 100%); }\n",
    "    .stButton>button { background-color: #16a34a; color: white; }\n",
    "    .large-font { font-size:20px !important; }\n",
    "    </style>\n",
    "    \"\"\",\n",
    "    unsafe_allow_html=True\n",
    ")\n",
    "\n",
    "st.title(\"âš¡ EnerGrow AI â€” Clean Energy Recommendation (Full Prototype)\")\n",
    "st.markdown(\"Prototype for EnerGrow AI: prediction, impact estimates, supplier matching, explainability, and PDF reports.\")\n",
    "\n",
    "# -------------------------\n",
    "# Sidebar: model insights & class distribution\n",
    "# -------------------------\n",
    "st.sidebar.header(\"Model & Data\")\n",
    "st.sidebar.write(\"Model: RandomForest prototype\")\n",
    "if df_ref is not None and \"Technology Adopted\" in df_ref.columns:\n",
    "    st.sidebar.write(\"Training class distribution:\")\n",
    "    st.sidebar.bar_chart(df_ref[\"Technology Adopted\"].value_counts())\n",
    "\n",
    "st.sidebar.markdown(\"---\")\n",
    "st.sidebar.write(\"Optional: Provide lat/lon to fetch local weather from Open-Meteo (no API key required).\")\n",
    "\n",
    "# -------------------------\n",
    "# Input form: farmer data (matching your CSV headers)\n",
    "# -------------------------\n",
    "with st.form(\"farmer_form\", clear_on_submit=False):\n",
    "    st.subheader(\"Enter farmer / household details\")\n",
    "    c1, c2, c3 = st.columns([1,1,1])\n",
    "\n",
    "    Location = c1.text_input(\"Location\", value=\"Kpaduma\")\n",
    "    AvgTemp = c1.number_input(\"Avg Temp (Â°C)\", value=30.0, step=0.1)\n",
    "    CropType = c1.text_input(\"Crop Type\", value=\"tomato\")\n",
    "\n",
    "    HarvestQty = c2.number_input(\"Harvest Quantity (kg)\", value=200.0)\n",
    "    CurrentFuel = c2.selectbox(\"Current Fuel\", options=[\"firewood\",\"charcoal\",\"LPG\",\"electricity\",\"none\"])\n",
    "    FuelConsumption = c2.number_input(\"Fuel Consumption (kg)\", value=10.0)\n",
    "\n",
    "    HealthImpact = c3.number_input(\"Health Impact Score (0â€“10)\", value=3.0, step=0.1)\n",
    "    PostHarvestLoss = c3.number_input(\"Post-Harvest Loss (%)\", value=25.0, step=0.1)\n",
    "    IncomeLevel = c3.number_input(\"Income Level (â‚¦)\", value=50000.0, step=1000.0)\n",
    "\n",
    "    AccessFinancing = c1.selectbox(\"Access to Financing\", options=[\"yes\",\"no\"])\n",
    "    YouthInvolvement = c2.selectbox(\"Youth Involvement\", options=[\"yes\",\"no\"])\n",
    "\n",
    "    # Optional geographic for weather\n",
    "    lat = c3.text_input(\"Latitude (optional)\", value=\"\")\n",
    "    lon = c3.text_input(\"Longitude (optional)\", value=\"\")\n",
    "\n",
    "    submitted = st.form_submit_button(\"Get Recommendation\")\n",
    "\n",
    "# -------------------------\n",
    "# Helper: prepare input dataframe and transform\n",
    "# -------------------------\n",
    "def prepare_input_df():\n",
    "    input_dict = {\n",
    "        \"Location\": Location,\n",
    "        \"Avg Temp (Ã‚Â°C)\": AvgTemp,\n",
    "        \"Crop Type\": CropType,\n",
    "        \"Harvest Quantity (kg)\": HarvestQty,\n",
    "        \"Current Fuel\": CurrentFuel,\n",
    "        \"Fuel Consumption (kg)\": FuelConsumption,\n",
    "        \"Health Impact Score\": HealthImpact,\n",
    "        \"Post-Harvest Loss (%)\": PostHarvestLoss,\n",
    "        \"Income Level\": IncomeLevel,\n",
    "        \"Access to Financing\": AccessFinancing,\n",
    "        \"Youth Involvement\": YouthInvolvement\n",
    "    }\n",
    "    X = pd.DataFrame([input_dict])\n",
    "    return X\n",
    "\n",
    "# -------------------------\n",
    "# SHAP helper\n",
    "# -------------------------\n",
    "def compute_shap_local(model, X_processed, feature_names):\n",
    "    try:\n",
    "        import shap\n",
    "        explainer = shap.TreeExplainer(model.named_steps['clf'])\n",
    "        # model expects processed input (numeric array)\n",
    "        shap_values = explainer.shap_values(X_processed)\n",
    "        return explainer, shap_values\n",
    "    except Exception as e:\n",
    "        return None, None\n",
    "\n",
    "# -------------------------\n",
    "# Weather fetch (Open-Meteo) if lat/lon provided\n",
    "# -------------------------\n",
    "def fetch_weather(lat, lon):\n",
    "    try:\n",
    "        url = f\"https://api.open-meteo.com/v1/forecast?latitude={lat}&longitude={lon}&hourly=temperature_2m,relativehumidity_2m&daily=temperature_2m_max,temperature_2m_min&timezone=auto\"\n",
    "        r = requests.get(url, timeout=6)\n",
    "        if r.status_code == 200:\n",
    "            return r.json()\n",
    "        else:\n",
    "            return None\n",
    "    except Exception:\n",
    "        return None\n",
    "\n",
    "# -------------------------\n",
    "# Cost-benefit & CO2 functions\n",
    "# -------------------------\n",
    "# Example baseline costs (â‚¦) â€” replace with real supplier prices\n",
    "BASE_COSTS = {\n",
    "    \"Solar Dryer\": 120000,\n",
    "    \"Efficient Cookstove\": 15000,\n",
    "    \"Biogas\": 450000,\n",
    "    \"None\": 0\n",
    "}\n",
    "\n",
    "def estimate_payback(cost_naira, annual_savings_naira):\n",
    "    if annual_savings_naira <= 0:\n",
    "        return None\n",
    "    months = (cost_naira / annual_savings_naira) * 12\n",
    "    return months\n",
    "\n",
    "def estimate_co2_reduction(annual_savings_naira):\n",
    "    # synthetic conversion: savings -> kg CO2 avoided\n",
    "    # adjust with real conversion factor later\n",
    "    return round(annual_savings_naira * 0.0002, 2)  # kg CO2/year\n",
    "\n",
    "# -------------------------\n",
    "# Supplier matching function\n",
    "# -------------------------\n",
    "def match_suppliers(tech, region=None):\n",
    "    matches = [s for s in SUPPLIERS if s[\"tech\"].lower().replace(\" \", \"\") == tech.lower().replace(\" \", \"\")]\n",
    "    if region:\n",
    "        matches = [s for s in matches if s[\"region\"].lower() in region.lower()]\n",
    "    return matches\n",
    "\n",
    "# -------------------------\n",
    "# ACTION on submit: predict, show results, compute extras\n",
    "# -------------------------\n",
    "if submitted:\n",
    "    X_raw = prepare_input_df()\n",
    "    st.write(\"### Input summary\")\n",
    "    st.dataframe(X_raw.T)\n",
    "\n",
    "    # Prepare encoded + scaled input copy\n",
    "    X_proc = X_raw.copy()\n",
    "\n",
    "    # 1) Encode categorical fields using label_encoders (they should map exactly those training columns)\n",
    "    for col, le in label_encoders.items():\n",
    "        if col in X_proc.columns:\n",
    "            val = X_proc.loc[0, col]\n",
    "            try:\n",
    "                X_proc.loc[0, col] = le.transform([val])[0]\n",
    "            except Exception:\n",
    "                # if unseen category, warn and map to a fallback (most frequent class)\n",
    "                fallback = le.classes_[0]\n",
    "                st.warning(f\"Input category '{val}' for column '{col}' unseen during training. Using fallback '{fallback}'.\")\n",
    "                X_proc.loc[0, col] = le.transform([fallback])[0]\n",
    "\n",
    "    # 2) Scale numeric features: determine numeric columns by excluding encoder keys\n",
    "    numeric_cols = [c for c in X_proc.columns if c not in label_encoders]\n",
    "    try:\n",
    "        X_proc[numeric_cols] = scaler.transform(X_proc[numeric_cols])\n",
    "    except Exception as e:\n",
    "        st.error(\"Scaler transform failed: \" + str(e))\n",
    "        st.stop()\n",
    "\n",
    "    # 3) Predict\n",
    "    try:\n",
    "        pred = model.predict(X_proc)[0]\n",
    "        probs = model.predict_proba(X_proc)[0]\n",
    "        classes = model.classes_\n",
    "        conf = round(np.max(probs) * 100, 2)\n",
    "    except Exception as e:\n",
    "        st.error(\"Prediction failed: \" + str(e))\n",
    "        st.stop()\n",
    "\n",
    "    st.success(f\"### ðŸŒ± Recommended: **{pred}** (confidence {conf}%)\")\n",
    "\n",
    "    # Show probability table\n",
    "    prob_df = pd.DataFrame({\"Technology\": classes, \"Probability\": probs})\n",
    "    st.write(\"#### Prediction probabilities\")\n",
    "    st.dataframe(prob_df.sort_values(\"Probability\", ascending=False).reset_index(drop=True))\n",
    "\n",
    "    # Cost-benefit estimates\n",
    "    default_cost = BASE_COSTS.get(pred, 0)\n",
    "    st.write(\"### Cost & Payback estimate\")\n",
    "    col_cost, col_savings = st.columns(2)\n",
    "\n",
    "    # allow user to override cost\n",
    "    cost_input = col_cost.number_input(\"Estimated equipment cost (â‚¦)\", value=float(default_cost))\n",
    "    # estimate annual savings as a fraction of cost or from input: we will compute simple formula:\n",
    "    # Assume annual savings = (PostHarvestLoss% reduction value * HarvestQty * market_price) simplistically.\n",
    "    # Lacking market price, use a proxy: 50 Naira/kg saved value (adjust to real data)\n",
    "    market_price_naira_per_kg = 50.0\n",
    "    saved_kg_per_year = (X_raw.loc[0, \"Post-Harvest Loss (%)\"] / 100.0) * X_raw.loc[0, \"Harvest Quantity (kg)\"] * 12 * 0.3\n",
    "    # 0.3 factor: conservative fraction expected to be saved after tech adoption (example)\n",
    "    est_annual_savings_naira = round(saved_kg_per_year * market_price_naira_per_kg, 2)\n",
    "    col_savings.metric(\"Estimated annual savings (â‚¦)\", f\"{est_annual_savings_naira}\")\n",
    "\n",
    "    payback_months = estimate_payback(cost_input, est_annual_savings_naira)\n",
    "    if payback_months is None:\n",
    "        st.warning(\"Estimated annual savings are zero or negative; payback cannot be computed.\")\n",
    "    else:\n",
    "        st.info(f\"Estimated payback: ~{payback_months:.1f} months ({payback_months/12:.1f} years)\")\n",
    "\n",
    "    # CO2 estimate\n",
    "    est_co2 = estimate_co2_reduction(est_annual_savings_naira)\n",
    "    st.write(f\"### Estimated COâ‚‚ reduction: **{est_co2} kg/year** (approximate)\")\n",
    "\n",
    "    # Match suppliers\n",
    "    st.write(\"### Suppliers that can provide this technology\")\n",
    "    matches = match_suppliers(pred, X_raw.loc[0, \"Location\"])\n",
    "    if matches:\n",
    "        for s in matches:\n",
    "            st.write(f\"- **{s['name']}** â€” {s['tech']} â€” â‚¦{s['price_naira']:,} â€” Region: {s['region']} â€” Phone: {s['phone']}\")\n",
    "    else:\n",
    "        st.write(\"No direct matches found in our small supplier directory. Extend the supplier DB for full coverage.\")\n",
    "\n",
    "    # Weather (if lat/lon provided)\n",
    "    if lat and lon:\n",
    "        w = fetch_weather(lat, lon)\n",
    "        if w:\n",
    "            st.write(\"### Weather snapshot from Open-Meteo (nearby coordinates)\")\n",
    "            # display simple daily summary\n",
    "            if 'daily' in w and 'temperature_2m_max' in w['daily']:\n",
    "                max_temps = w['daily'].get('temperature_2m_max', [])\n",
    "                min_temps = w['daily'].get('temperature_2m_min', [])\n",
    "                st.write(f\"Next days max temp: {max_temps[:5]}\")\n",
    "                st.write(f\"Next days min temp: {min_temps[:5]}\")\n",
    "        else:\n",
    "            st.write(\"Weather fetch failed â€” check latitude/longitude or network.\")\n",
    "\n",
    "    # SHAP explainability (local)\n",
    "    st.write(\"### Model explainability (SHAP)\")\n",
    "    try:\n",
    "        # For shap we need to get processed input used by model pipeline\n",
    "        # Model is assumed to be a pipeline with preproc and clf\n",
    "        processed = model.named_steps['preproc'].transform(X_raw.replace(np.nan, 0))\n",
    "        explainer, shap_vals = None, None\n",
    "        try:\n",
    "            import shap\n",
    "            explainer = shap.TreeExplainer(model.named_steps['clf'])\n",
    "            shap_vals = explainer.shap_values(processed)\n",
    "        except Exception as e:\n",
    "            st.write(\"SHAP not available for this model or failed: \" + str(e))\n",
    "        if explainer is not None and shap_vals is not None:\n",
    "            # show top features for the predicted class\n",
    "            idx = list(model.classes_).index(pred)\n",
    "            # We will display a simple bar of absolute shap values locally\n",
    "            shap_arr = np.abs(shap_vals[idx][0])\n",
    "            # Feature names from preprocessor\n",
    "            try:\n",
    "                feat_names = model.named_steps['preproc'].get_feature_names_out()\n",
    "            except Exception:\n",
    "                # fallback: numeric + categorical raw names\n",
    "                feat_names = list(X_raw.columns)\n",
    "            feat_imp = pd.DataFrame({\"feature\": feat_names, \"importance\": shap_arr}).sort_values(\"importance\", ascending=False).head(10)\n",
    "            st.dataframe(feat_imp)\n",
    "        else:\n",
    "            st.write(\"SHAP explanation not available for this pipeline.\")\n",
    "    except Exception as e:\n",
    "        st.write(\"Explainability step failed: \" + str(e))\n",
    "\n",
    "    # -------------------------\n",
    "    # Generate PDF report (downloadable)\n",
    "    # -------------------------\n",
    "    def create_pdf_report(input_df, pred, conf, est_savings, payback_months, est_co2, suppliers_list):\n",
    "        pdf = FPDF()\n",
    "        pdf.add_page()\n",
    "        pdf.set_font(\"Arial\", size=12)\n",
    "        pdf.cell(0, 8, txt=\"EnerGrow AI - Recommendation Report\", ln=True, align=\"C\")\n",
    "        pdf.ln(4)\n",
    "        pdf.set_font(\"Arial\", size=10)\n",
    "        pdf.cell(0, 6, txt=f\"Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M')}\", ln=True)\n",
    "        pdf.ln(4)\n",
    "        pdf.cell(0, 6, txt=\"Input summary:\", ln=True)\n",
    "        for k, v in input_df.iloc[0].items():\n",
    "            pdf.cell(0, 6, txt=f\" - {k}: {v}\", ln=True)\n",
    "        pdf.ln(4)\n",
    "        pdf.cell(0, 6, txt=f\"Recommended Technology: {pred} (confidence: {conf}%)\", ln=True)\n",
    "        pdf.cell(0, 6, txt=f\"Estimated annual savings (â‚¦): {est_savings}\", ln=True)\n",
    "        if payback_months:\n",
    "            pdf.cell(0, 6, txt=f\"Estimated payback (months): {payback_months:.1f}\", ln=True)\n",
    "        pdf.cell(0, 6, txt=f\"Estimated CO2 reduction (kg/year): {est_co2}\", ln=True)\n",
    "        pdf.ln(4)\n",
    "        pdf.cell(0, 6, txt=\"Suppliers:\", ln=True)\n",
    "        if suppliers_list:\n",
    "            for s in suppliers_list:\n",
    "                pdf.cell(0, 6, txt=f\" - {s['name']} | {s['tech']} | â‚¦{s['price_naira']:,} | {s['phone']}\", ln=True)\n",
    "        else:\n",
    "            pdf.cell(0, 6, txt=\" - No suppliers found in local DB\", ln=True)\n",
    "        # return bytes\n",
    "        return pdf.output(dest='S').encode('latin-1')\n",
    "\n",
    "    pdf_bytes = create_pdf_report(X_raw, pred, conf, est_annual_savings_naira, payback_months, est_co2, matches)\n",
    "    st.download_button(\"ðŸ“„ Download recommendation report (PDF)\", data=pdf_bytes, file_name=\"energrow_report.pdf\", mime=\"application/pdf\")\n",
    "\n",
    "    # -------------------------\n",
    "    # Logging prediction to CSV for later labeling\n",
    "    # -------------------------\n",
    "    log_row = X_raw.copy()\n",
    "    log_row[\"prediction\"] = pred\n",
    "    log_row[\"confidence\"] = conf\n",
    "    log_row[\"estimated_annual_savings_naira\"] = est_annual_savings_naira\n",
    "    log_row[\"estimated_co2_kg_per_year\"] = est_co2\n",
    "    log_row[\"timestamp\"] = datetime.datetime.now().isoformat()\n",
    "    if os.path.exists(LOG_FILE):\n",
    "        log_row.to_csv(LOG_FILE, mode='a', header=False, index=False)\n",
    "    else:\n",
    "        log_row.to_csv(LOG_FILE, index=False)\n",
    "    st.success(\"Prediction logged to disk for monitoring and future labeling.\")\n",
    "\n",
    "# -------------------------\n",
    "# Footer\n",
    "# -------------------------\n",
    "st.markdown(\"---\")\n",
    "st.write(\"EnerGrow AI prototype â€” built to help farmers choose cost-effective clean energy solutions. Validate all recommendations with local technicians and real-world pilots.\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
